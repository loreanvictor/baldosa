<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1, user-scalable=no">
<title>Baldosa: the cloud city</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700&family=Open+Sans:wght@300..800&display=swap" rel="stylesheet">
<style>
  html, body {
    margin:0; padding:0; overflow:hidden; height:100%; width:100%;
    background: #000; color: #fff;
    * {
      font-family: "Open Sans", sans-serif;
    }
  }
  canvas {
    display:block;
    width:100vw;
    height:100vh;
    cursor: pointer;
    touch-action: none; /* Prevent default gestures */
  }
</style>
</head>
<body>
<canvas id="gridCanvas"></canvas>
<footer>
  <pan-indicator camera="camera-control"></pan-indicator>
  <zoom-indicator camera="camera-control"></zoom-indicator>
  <camera-control target="canvas"></camera-control>
  <track-cursor></track-cursor>
</footer>
<script type="module">
  import './client/control/camera-control.js'
  import './client/control/track-cursor.js'
  import './client/control/pan-indicator.js'
  import './client/control/zoom-indicator.js'

  import { fetchImage } from './client/render/image/fetch.js'
  import { drawTile } from './client/render/tile.js'
  import { PICSUM_IDS } from './client/util/picsum-ids.js'

  const IMG_SIZES = {i: 1, xs: 48, s: 96, m: 156, l: 300};
  const BLUR_MAP = {xs: 1, s: 1};

  const data = new Map()
  data.set('0,0',
    {
      x: 0, y: 0,
      background: '#EFA73E',
      image: { i: '/sign.png' },
    }
  );
  
  const titles = [
    'A little cute cat',
    'Some weird stuff',
    'I have no idea',
    'Can you believe this?',
    'Fun Stuff',
    'BEST DEAL!',
    'All the love',
    'Luxury Cat',
  ];
  const subtitles = [
    '40$',
    '130$',
    'Contact me for prices',
    '@SomeDude on WhatsApp',
    '+4997312374',
    'Email: some@dude.com',
    'https://cool-cats.shady/shop',
    'Will exchange for PS5',
    'Want ASAP from Jan 1st',
    'Dude what are you talking about?',
    'I am not really sure',
    'Please only contact at night',
    'Also sell drugs',
  ];
  const colors = [
    '#f3c15f', '#e76d2d', '#d22e40', '#c42a6f',
    '#652ca4', '#2050b3', '#54b9de', '#469c9f',
    '#43977d', '#52b469', '#9dd441', '#e0e24b',
  ];
  for (let i = -500; i <= 500; i++) {
    for (let j = -500; j <= 500; j++) {
      if (Math.abs(i) <= 1 && Math.abs(j) <= 1 && i * j === 0) {
        continue;
      }
      
      if (Math.random() > 0.95) {
        continue;
      }
      
      const post = {
        x: i, y: j,
        title: titles[Math.floor(Math.random() * titles.length)],
        subtitle: subtitles[Math.floor(Math.random() * subtitles.length)],
        image: { },
      }

      const imgrand = `${i+500}-${j+500}`;
      const idx = Math.floor(Math.random() * PICSUM_IDS.length);
      const imgid = PICSUM_IDS[idx];
      Object.keys(IMG_SIZES).forEach(size => {
        post.image[size] = `https://picsum.photos/id/${imgid}/${IMG_SIZES[size]}?r=${imgrand}`
          + (BLUR_MAP[size] ? `&blur=${BLUR_MAP[size]}` : '')
      });
      
      if (Math.random() > 0.8) {
        delete post['title'];
        delete post['subtitle'];
      } else if (Math.random() > 0.7) {
        if (Math.random() > 0.5) {
          post['title'] = post['subtitle'];
        }
        
        delete post['subtitle'];
      } else if (Math.random() > 0.9) {
        delete post['image'];
        post['background'] = colors[Math.floor(Math.random() * colors.length)];
        post['color'] = '#000';
      }
      
      data.set(`${i},${j}`, post);
    }
  }
  
  function getData(x, y) {
    return data.get(`${x},${y}`)
  }

  window._d = getData
  window._pid = PICSUM_IDS
  
  const imageCache = new Map();
  const loading = {};
  
  function fillSquareWithImage(img, x, y, size) {
    const iw = img.width;
    const ih = img.height;

    const k = size / Math.min(iw, ih);
    const dw = iw * k;
    const dh = ih * k;
    const dx = x + (size - dw) / 2;
    const dy = y + (size - dh) / 2;
    
    return [dx, dy, dw, dh];
  };

  
  async function addImageSize(record, size, urls) {
    if (record[size] && record[size] !== 'loading') {
      return;
    }
    
    record[size] = 'loading';
    record[size] = await fetchImage(urls[size]);
  }
  
  function getImage(urls, scale) {
    let hit = imageCache.get(urls.i);
    if (hit) {
      hit.t = Date.now()

      const sizes = Object.keys(IMG_SIZES).filter(size => size in urls);
      const target = sizes.reduce(
        (curr, candidate) =>
           (IMG_SIZES[curr] < IMG_SIZES[candidate] && IMG_SIZES[curr] < scale)
           ? candidate : curr
      );

      if (!hit[target]) {
        hit[target] = 'loading';
        setTimeout(() => addImageSize(hit, target, urls), 10);
      }
      
      const available = hit[target] !== 'loading' ? target :
        sizes.reduce(
          (curr, candidate) => (
            hit[candidate] && (hit[candidate] !== 'loading') &&
            IMG_SIZES[candidate] >= (IMG_SIZES[curr] ?? 1) &&
            IMG_SIZES[curr] < scale
          ) ? candidate : curr
        );
      
      return available ? hit[available] : hit.i;
    } else if (!loading[urls.i]) {
      loading[urls.i] = true;
      const load = async() => {
        try {
          // TODO: this is weird, why don't we attempt to get the requested size directly?
          const img = await fetchImage(urls.i);
          
          const record = {
            i: img, t: Date.now(),
          };
          
          imageCache.set(urls.i, record);
        } catch(err) {
          console.log(err.message);
        } finally {
          delete loading[urls.i];
        }
      };
      
      setTimeout(() => load(), 1);
    }
    
    return undefined;
  }
  
  const wmin = Math.min(window.innerWidth, window.innerHeight);
  const wmax = Math.max(window.innerWidth, window.innerHeight);
  const SMALL_DEVICE = wmax <= 800;
  const MIN_SCALE = SMALL_DEVICE ? wmin / 4 : wmin / 5;
  const MAX_SCALE = 300;

  const IMG_CACHE_SIZE = (Math.ceil(wmin / MIN_SCALE) + 4) * (Math.ceil(wmax / MIN_SCALE) + 4) * 2;
  
  setInterval(() => {
    if (imageCache.size > IMG_CACHE_SIZE) {
      const entries = [...imageCache.entries()].sort((i, j) => i[1].t - j[1].t)
      const target = entries.slice(0, imageCache.size - IMG_CACHE_SIZE);
      target.forEach(entry => {
        setTimeout(() => {
          Object.keys(IMG_SIZES).forEach(size => {
            if (entry[1][size] && entry[1][size] !== 'loading') {
              entry[1][size].close();
            }
          });
          imageCache.delete(entry[0]);
        }, 1);
      });
    } else {
      const now = Date.now();
      [...imageCache.entries()]
        .filter(i => now - i[1].t > 10_000)
        .forEach(e => {
          Object.keys(IMG_SIZES).forEach(size => {
            if (e[1][size] && e[1][size] !== 'loading') {
              e[1][size].close();
            }
          });
          imageCache.delete(e[0]);
        })
     ;
    }
  }, 200);
  
  const canvas = document.getElementById('gridCanvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  
  let width, height;
  function resizeCanvas() {
    width = window.innerWidth;
    height = window.innerHeight + (SMALL_DEVICE ? 80 : 0);

    canvas.width = width * devicePixelRatio;
    canvas.height = height * devicePixelRatio;

    ctx.resetTransform()
    ctx.scale(devicePixelRatio, devicePixelRatio);
  }
  
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();
  
  const supportsHover = window.matchMedia('(any-hover: hover)').matches;
  
  let cameraX = .5;
  let cameraY = .5;
  let scale = SMALL_DEVICE ? Math.min(wmin / 2.5, MAX_SCALE) : Math.min(wmin / 3.5, MAX_SCALE);
  const startScale = scale;
  
  let mouseX = -Infinity;
  let mouseY = -Infinity;
  let panv = 0;

  const cursor = document.querySelector('track-cursor')
  cursor.addEventListener('move', ({ detail }) => {
    mouseX = detail.x;
    mouseY = detail.y;
  })

  const camera = document.querySelector('camera-control')
  camera.setAttribute('camx', cameraX)
  camera.setAttribute('camy', cameraY)
  camera.setAttribute('zoom', startScale)
  camera.setAttribute('minzoom', MIN_SCALE)
  camera.setAttribute('maxzoom', MAX_SCALE)
  camera.addEventListener('pan', ({ detail }) => {
    cameraX = detail.camera.x
    cameraY = detail.camera.y

    panv = Math.sqrt(
      detail.velocity.x * detail.velocity.x
      + detail.velocity.y * detail.velocity.y
    ) / scale
  })
  camera.addEventListener('zoom', ({ detail }) => {
    scale = detail.zoom
  })

  const panind = document.querySelector('pan-indicator')
  panind.addEventListener('pan', ({ detail }) => {
    camera.setAttribute('camx', detail.x + .5)
    camera.setAttribute('camy', detail.y + .5)
  })

  let lastHoveredTile;
  function draw() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, width, height);

    const leftCell = Math.floor(cameraX - width/(2*scale)) - 2;
    const rightCell = Math.floor(cameraX + width/(2*scale)) + 2;
    const topCell = Math.floor(cameraY - height/(2*scale)) - 2;
    const bottomCell = Math.floor(cameraY + height/(2*scale)) + 2;

    const bounds = { width, height, wmin };
    const camera = { x: cameraX, y: cameraY, zoom: scale, v: panv };
    const mouse = {
      x: mouseX, y: mouseY, supportsHover,
      onHover: tile => {
        if (lastHoveredTile !== tile) {
          panind.setAttribute('x', tile.x)
          panind.setAttribute('y', tile.y)
        }

        lastHoveredTile = tile
      }
    };
    const imageLoader = { getImage, fillSquareWithImage };
    for (let x = leftCell; x <= rightCell; x++) {
      for (let y = topCell; y <= bottomCell; y++) {
        const tile = {
          x, y, data: getData(x, y)
        };
        drawTile(ctx, tile, bounds, camera, mouse, imageLoader);
      }
    }

    requestAnimationFrame(draw);
  }

  requestAnimationFrame(draw);
</script>
</body>
</html>
