
use async_trait::async_trait;
use std::sync::Arc;
use futures::stream::StreamExt;
use image::Pixel;

use super::super::schedule::Task;
use super::super::storage::{ Storage, Coords };
use super::target::BitmaskTarget;

use log::info;


const CHUNK_SIZE: i32 = 256;
const BITMAP_SIZE: usize = (CHUNK_SIZE * CHUNK_SIZE) as usize / 8;


///
/// Get the coordinates of the chunk containing the given coordinates.
/// The chunk coordinates are the coordinates of the top-left corner of the chunk.
/// The chunk size is 256x256.
///
pub fn get_chunk_coords(coords: &Coords) -> Coords {
  (coords.0.div_euclid(CHUNK_SIZE) * CHUNK_SIZE, coords.1.div_euclid(CHUNK_SIZE) * CHUNK_SIZE)
}

///
/// A task that generates a bitmask for a chunk of the map and stores it
/// in the given bitmask target. The bitmask is generated by iterating over
/// the points stored in the storage within the chunk and setting the
/// corresponding bit in the bitmask for each point.
/// 
/// From a given bitmask, we can quickly determine if a point exists within
/// the chunk (i.e. if a tile is published or not):
/// ```rs
/// // find the bit to check:
/// let lx = x - chunk.x;
/// let ly = y - chunk.y;
/// let bit_index = (lx + ly * CHUNK_SIZE) as usize;
/// let byte_index = bit_index / 8;
/// let bit_offset = bit_index % 8;
/// 
/// // check if the bit is set in the bitmask:
/// (bitmask[byte_index] & (1 << bit_offset)) != 0
/// ```
///
#[derive(Clone)]
pub struct GenerateAndStoreBitmaskTask<P: Pixel + Send + Sync + 'static> {
  storage: Arc<dyn Storage<P>>,
  target: Arc<dyn BitmaskTarget>,
}

impl <P: Pixel + Send + Sync + 'static> GenerateAndStoreBitmaskTask<P> {
  pub fn new(storage: Arc<dyn Storage<P>>, target: Arc<dyn BitmaskTarget>) -> Self {
    Self {
      storage,
      target,
    }
  }
}

#[async_trait]
impl <P: Pixel + Send + Sync> Task for GenerateAndStoreBitmaskTask<P>
where <P as Pixel>::Subpixel: Send + Sync {
  async fn run(&self, start: &Coords) {
    info!("Generating bitmask for coords {:?}", start);

    //
    // create a bitmask for the chunk
    //
    let mut bitmask = vec![0u8; BITMAP_SIZE];

    //
    // get the stored coordinates within the chunk
    //
    let end = (start.0 + CHUNK_SIZE, start.1 + CHUNK_SIZE);
    let mut points = self.storage.get(&start, &end).await;

    //
    // set the corresponding bit of each point
    //
    while let Some(point) = points.next().await {

      // the position of the point within the chunk
      let pos = (point.coords.0 - start.0, point.coords.1 - start.1);

      // the index of the bit in the bitmask
      let bit_index = (pos.0 + pos.1 * CHUNK_SIZE) as usize;

      // the index of the byte containing target bit
      let byte_index = bit_index / 8;

      // the offset of the target bit within the byte
      let bit_offset = bit_index % 8;

      if byte_index < bitmask.len() {
        // flip the bit to 1
        bitmask[byte_index] |= 1 << bit_offset;
      }
    }

    match self.target.save_bitmask(&start, &bitmask).await {
      Ok(()) => info!("Bitmask for coords {:?} saved", start),
      Err(err) => info!("Error saving bitmask for coords {:?}: {}", start, err),
    }
  }
}
