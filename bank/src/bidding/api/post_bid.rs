use std::collections::HashMap;

use axum::{
  extract::{Extension, Json, Path},
  response::IntoResponse,
};
use s3::bucket::Bucket;
use serde::{Deserialize, Serialize};
use sqlx::types::Uuid;

use super::super::book::{BidContent, Book, Coords};
use super::super::config::Config;
use super::super::error::BiddingError;
use super::super::publisher::Publisher;
use super::super::upload;
use super::auth::OwnedBidById;
use super::publish::publish;
use super::validate::{validate_content, validate_tx};
use crate::auth::AuthenticatedUser;
use crate::wallet::{auth::UsableOutgoingOffer, Ledger};

#[derive(Serialize)]
pub struct InitResponse {
  upload_url: String,
  upload_fields: HashMap<String, String>,
}

///
/// Initializes a bid by generating a signed upload URL for the image.
/// The user can use this URL to upload their image to S3, and then
/// post the bid using the uploaded image URL.
///
/// To prevent abuse, this endpoint only allows uploading images
/// when a valid transaction is provided. The transaction doesn't need
/// to be used for the actual bid, it simply needs to be unconsumed and not
/// earmarked for another purpose. The upload target is unique based
/// on the coordinates and the transaction ID, so only one image is kept in S3
/// per transaction. Repeat uploads will overwrite the previous image.
///
/// ## Using the Signed URL
/// This endpoint returns a URL, alongside a set of fields, which can be used to upload
/// the image like this:
/// ```js
/// const { upload_url, upload_fields } =
///   await fetch('/api/bid/42:3/init', ...)
///         .then(res => res.json())
///
/// const formData = new FormData()
/// Object.entries(upload_fields).forEach(([key, value]) => {
///  formData.append(key, value)
/// })
/// formData.append('file', file) // where `file` is a File object, or a Blob
/// await fetch(upload_url, {
///   method: 'POST',
///   body: formData
/// })
/// ```
/// - The URL is valid for a limited time
/// - The size and type of the image must match the requirements specified in the `Config`
///
pub async fn init_bid(
  Extension(bucket): Extension<Bucket>,
  Extension(book): Extension<Book>,
  Extension(config): Extension<Config>,
  Path(coords): Path<Coords>,
  UsableOutgoingOffer(tx, bidder): UsableOutgoingOffer,
) -> Result<impl IntoResponse, BiddingError> {
  validate_tx(&book, &tx, &bidder, coords, &config).await?;

  match upload::generate_url(&bucket, coords, &tx, &config.image_upload).await {
    Ok(res) => Ok(Json(InitResponse {
      upload_url: res.url.to_string(),
      upload_fields: res.fields,
    })),
    Err(_) => Err(BiddingError::Unknown),
  }
}

#[derive(Deserialize)]
pub struct PostBidBody {
  title: String,
  image: String,
  transaction_id: Uuid,
  subtitle: Option<String>,
  description: Option<String>,
  url: Option<String>,
}

///
/// Posts a bid with the given details.
/// The image URL must be a valid S3 URL that was generated by the `init_bid` endpoint.
///
/// If the coordinates is not occupied by some other content, or if the content has been
/// published longer than the minimum guaranteed occupancy for each tile, then the content
/// will be published immediately. Otherwise, it will be published at the next auction time
/// (if no higher bids are placed).
///
pub async fn post_bid(
  Extension(book): Extension<Book>,
  Extension(ledger): Extension<Ledger>,
  Extension(publisher): Extension<Publisher>,
  Extension(config): Extension<Config>,
  bidder: AuthenticatedUser,
  Path(coords): Path<Coords>,
  Json(body): Json<PostBidBody>,
) -> Result<impl IntoResponse, BiddingError> {
  let tx = ledger
    .get_transaction(&body.transaction_id)
    .await
    .map_err(|_| BiddingError::IncorrectTransaction)?;
  validate_tx(&book, &tx, &bidder, coords, &config).await?;

  let content = BidContent {
    title: Some(body.title),
    image: Some(body.image),
    subtitle: body.subtitle,
    description: body.description,
    url: body.url,
  };
  validate_content(&content)?;

  match book
    .record_bid(
      &tx,
      coords,
      content,
      i32::try_from(tx.total()).unwrap_or_default(),
    )
    .await
  {
    Ok(mut bid) => {
      if book
        .should_publish_immediately(&bid)
        .await
        .map_err(|_| BiddingError::Unknown)?
      {
        publish(&mut bid, &tx, &book, &publisher, &ledger).await?;
      }

      Ok(Json(bid))
    }
    Err(_) => Err(BiddingError::Unknown),
  }
}

pub async fn rescind_bid(
  Extension(book): Extension<Book>,
  Extension(ledger): Extension<Ledger>,
  OwnedBidById(bid, bidder): OwnedBidById,
) -> Result<impl IntoResponse, BiddingError> {
  let tx = ledger
    .get_transaction(&bid.tx)
    .await
    .map_err(|_| BiddingError::IncorrectTransaction)?;
  if !tx.is_usable_offer_from(&bidder.id) {
    return Err(BiddingError::UnauthorizedTransaction);
  }

  ledger
    .rescind_offer(&tx, &bidder)
    .await
    .map_err(|_| BiddingError::Unknown)?;
  match book.rescind_bid(&bid, &bidder).await {
    Ok(()) => Ok(()),
    Err(_) => Err(BiddingError::Unknown),
  }
}
